

if err != nil {		}		reak		if err == io.EOF {		err := d.Decode(&v)		var v interface{}	for {	var m map[string]interface{}d := json.NewDecoder(r)func isValidJsonNewline(r io.Reader) (bool, error) {}	return true, nil	}		return false, nil	f m == nil {	}		m = t		}			return false, fmt.Errorf("Not valid")		if !ok {		, ok := v.([]interface{})		}			return false, err		if err != nil {		}			reak		if err == io.EOF {		err := d.Decode(&v)		var v interface{}	for {	var m []interface{}	d := json.NewDecoder(r)func isValidJsonArray(r io.Reader) (bool, error) {}	return ch	ch := getFirstNonWhitespaceCharacter(br)	br := bufio.NewReader(r)func getJsonType(r io.Reader) JsonType {}	}		}			}				return IllegalJson			default:				return JsonNewline			case '{':			eturn JsonArray			case '[':			switch ch {		if !isWhitespace(ch) {		}			eturn IllegalJson		if err != nil {		ch, _, err := br.ReadRune()	for {	// Consume whitespace characters	br := bufio.NewReader(r)func getFirstNonWhitespaceCharacter(r io.Reader) JsonType {}	return ch == ' ' || ch == '\t' || ch == '\n'func isWhitespace(ch rune) bool {// dataset.key: if dataset// dataset[N]: if dataset is an array of json//////     - including single json with big array inside// json lines// Array of json// Grammar// Comma-separated json in an array// Newline-delimited json// Data Formats supported)	sonNewline	JsonArray	IllegalJson JsonType = iotaconst (type JsonType int)	CurlyBrace	SquareBracket	IllegalToken Token = iotaconst (type Token int}	fmt.Println(ff)	}		log.Fatal(err)	if err != nil {	err = ff.Capture()	fmt.Println(ff)	}	og.Fatal(err)	if err != nil {	err = ff.Capture()	}		fmt.Println("valid: ", valid)		}			log.Fatal(err)			fmt.Println("valid: ", valid)		if err != nil {		valid, err := isValidJsonNewline(ff.content)	fmt.Println("Json Newline")	if jsontype == JsonNewline {	// Validate Valid Json	}		fmt.Println("valid: ", valid)		}			log.Fatal(err)			fmt.Println("valid: ", valid)		if err != nil {		valid, err := isValidJsonArray(ff.content)		fmt.Println("Json Array")	if jsontype == JsonArray {	// Validate Valid Json	}	og.Fatal("Illegal Json")	if jsontype == IllegalJson {	jsontype := getJsonType(ff.content)	file.Close()	}		log.Fatal(err)	if err != nil {	ff.content.Write(content)	content, err := ioutil.ReadAll(file)	ff := NewJsonFile()	}		og.Fatal(err)	if err != nil {	file, err := os.Open(*filename)	// Validate the Json File Type	flag.Parse()func main() {}	return j.content.String()func (j *JsonFile) String() string {}	return nil	j.content.Write(losbytes)	j.content.Reset()	}		eturn err	if err != nil {	losbytes, err := capture.CaptureInputFromEditor(j.content.Bytes(), capture.GetPreferredEditorFromEnvironment)func (j *JsonFile) Capture() error
